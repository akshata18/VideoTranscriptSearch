(Refer Slide Time: 15:28) 

 What does the Rules Section have? This is the heart of a LEX specification. It contains patterns and it contains C-code. A line starting with white space or material, which is enclosed in the markers: percent flower bracket and percent flower bracket; is all C-code. This is very similar to the C-code, which is included in the Definitions Section as well. Then, anything else; if a line begins with anything else, it is a pattern. Pattern lines contain a pattern and then some C-code. Pattern, action in C code. We will see examples of this; that is how it is written. The C code lines are not processed by the LEX compiler at all. There are just taken and copied to the output. The patterns are regular expressions. So, they are translated into Nondeterministic Finite Automat, NFA. These are then converted to Deterministic Finite Automata because it is difficult to implement NFA’s. These DFA’s can be optimized. Why? There is a very famous theorem, which says – all forms of the same DFA can be converted to the minimal form. The state minimization theorem enables this and these DFA‘s are all stored in the form of a table and a driver routine. The action associated with the pattern is executed when the DFA recognizes a string corresponding to that pattern and then reaches final state. This is very similar to what happens in a finite state machine – you start off from the initial state, then you feed characters through the various states, then the transition happens, each transition leads you to a new state, and finally, you reach a final state. When you reach a final state, you have really recognized that particular pattern and then you can actually do some action. (Refer Slide Time: 17:52) 

 Here is a nice simple example of a LEX program, which is used as part of an expression parser later on. 

There are actually many of these tokens, which are recognized by this particular LEX specification. There is a Definition Section, which shows two definitions: There is number definition and then there is a name definition. The number definition simply defines a number; the first part is 0 dash 9 plus back slash dot question mark; looks difficult, but it trivially says – the number is any number of digits followed by a dot which is an option. Then, there is a bar. The bar says – either this or that. So, number could also be 0 to 9 star followed by dot and then followed by 0 to 9 plus. In other words, the meaning of that is any number of digits followed by a dot followed by any number of digits again. Only thing is, it makes compulsory to have a digit after the dot, if 

the dot is present. Similarly, the name itself could be A to Z capitals a to z small 

followed by any of the letter A to Z small a to z, or any of the letter and numeral 0 to 9 

any number of times; that is the star. So, we are really looking at letter followed by letter or the digit star. 

Once the regular expression number is recognized, it has a small action following it, which is the scanf. What does an scanf do? The scanf really takes the text of that particular token; that is, the numerals, which make that number, but it is still not in binary form. So, it reads it into a variable called yylval. yylval is a variable, which is generated by LEX. It is already known to us and it is understood by LEX as well. This yylval is principally used to transfer the values from the lexical analyzer to the parser. For example, here we are reading a number and later, in the parser, for expressions, we will use the value of this particular number. How do we communicate the value from the lexical analyzer to the parser? That is through the variable yylval. The return NUMBER says – the token, which is generated is number and that is returned by this particular function; piece of action code. Whatever is written in capitals, for example, number, name, postplus and postminus; these are actually tokens. As we will see very soon, these tokens are really defined in the parser and the lexical analyzer is supposed to recognize and pass them to the parser. The second one, the name; there is little more processing, which is done here. Once name is recognized, the symbol table is looked up; symlook actually with yytext. yytext is the text of the name itself; the characters corresponding to the name. symlook is the symbol table routine. It looks up the symbol table routine and then if it is already present, it actually gives you a pointer to it. If it is not present, it will insert the name into the symbol table and spread on its pointer. What is yylval? In this case, (Refer Slide Time: 22:12) yylval is actually the pointer value itself. yylval dot symp is nothing but the pointer value, which is a pointer into the symbol table for that particular name. What is the token? Token is the integer code name, which is returned by this action code. Similarly, for double plus, it returns POSTPLUS; for double minus, it returns POSTMINUS, for the end of file dollar, it returns a 0, and any other character including new line, it simply returns the character itself. 




